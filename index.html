<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>2D Ray Tracing JS Touch Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="manifest" href="/app.webmanifest">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            background-color: #000;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <canvas id="rayTracingCanvas"></canvas>
    <script>
        const canvas = document.getElementById('rayTracingCanvas');
        const ctx = canvas.getContext('2d');
        const FOV = 160; 
        let viewDirectionAngle = 45;
        let width, height, centerX, centerY;
        const objects = [];
        const MAX_VISION_DISTANCE = 250;
        const CLEAR_VISION_DISTANCE = 50; 
        const MAX_RAY_OPACITY = 0.7; 
        const NUM_RAYS = 256;

        function setCanvasSize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            centerX = width / 2;
            centerY = height / 2;
            objects.length = 0;
            objects.push({ x: width * 0.25, y: height * 0.25, w: 50, h: 200, color: [0, 0, 255] });
            objects.push({ x: width * 0.75, y: height * 0.6, w: 100, h: 50, color: [0, 255, 0] });
        }

        function drawPixel(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, 1, 1);
        }

        function traceRay(angle) {
            let x = centerX;
            let y = centerY;
            const rad = angle * Math.PI / 180;
            const dx = Math.cos(rad);
            const dy = Math.sin(rad);
            let hitObject = null;
            
            for (let i = 0; i < MAX_VISION_DISTANCE; i++) {
                x += dx;
                y += dy;
                const distance = i;
                const floorX = Math.floor(x);
                const floorY = Math.floor(y);

                if (distance > MAX_VISION_DISTANCE || floorX < 0 || floorX >= width || floorY < 0 || floorY >= height) {
                    break;
                }

                for (const obj of objects) {
                    if (x > obj.x && x < obj.x + obj.w && y > obj.y && y < obj.y + obj.h) {
                        hitObject = obj;
                        break;
                    }
                }

                if (hitObject) {
                    drawHitPoint(x, y, distance, hitObject.color);
                    break;
                }

                drawRayPathPixel(x, y, distance);
            }
        }
        
        function drawRayPathPixel(x, y, distance) {
            let opacity = MAX_RAY_OPACITY; 
            if (distance > CLEAR_VISION_DISTANCE) {
                const attenuation = (distance - CLEAR_VISION_DISTANCE) / (MAX_VISION_DISTANCE - CLEAR_VISION_DISTANCE);
                opacity = MAX_RAY_OPACITY * (1 - attenuation);
            }
            if (opacity > 0) {
                drawPixel(Math.floor(x), Math.floor(y), `rgba(255, 255, 0, ${opacity})`);
            }
        }

        function drawHitPoint(x, y, distance, objectColor) {
            let lightIntensity = 1.0; 
            if (distance > CLEAR_VISION_DISTANCE) {
                const attenuation = (distance - CLEAR_VISION_DISTANCE) / (MAX_VISION_DISTANCE - CLEAR_VISION_DISTANCE);
                lightIntensity = 1.0 * (1 - attenuation);
            }

            if (lightIntensity > 0) {
                const finalR = Math.min(255, objectColor[0] * lightIntensity + 255 * lightIntensity);
                const finalG = Math.min(255, objectColor[1] * lightIntensity + 255 * lightIntensity);
                const finalB = Math.min(255, objectColor[2] * lightIntensity + 0 * lightIntensity);
                drawPixel(Math.floor(x), Math.floor(y), `rgba(${finalR}, ${finalG}, ${finalB}, 1.0)`);
            }
        }

        function drawObjects() {}
        
        function renderScene() {
            ctx.clearRect(0, 0, width, height); 
            drawObjects();
            const startAngle = viewDirectionAngle - FOV / 2;
            const angleStep = FOV / (NUM_RAYS - 1);

            for (let i = 0; i < NUM_RAYS; i++) {
                const angle = startAngle + i * angleStep;
                traceRay(angle);
            }
        }

        function handleMove(clientX, clientY) {
            const dx = clientX - centerX;
            const dy = clientY - centerY;
            const angleRad = Math.atan2(dy, dx);
            let targetAngle = angleRad * 180 / Math.PI;
            const smoothing = 0.1;
            viewDirectionAngle += (targetAngle - viewDirectionAngle) * smoothing;
        }
        
        canvas.addEventListener('mousemove', (event) => {
            handleMove(event.clientX, event.clientY);
        });

        canvas.addEventListener('touchmove', (event) => {
            if (event.touches.length > 0) {
                handleMove(event.touches[0].clientX, event.touches[0].clientY);
            }
        });

        function gameLoop() {
            renderScene();
            requestAnimationFrame(gameLoop);
        }

        function initializeScene() {
            setCanvasSize();
            requestAnimationFrame(gameLoop);
        }

        // --- Регистрация Service Worker ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js').then(registration => {
                    console.log('Service Worker registered: ', registration.scope);
                }).catch(err => {
                    console.error('Service Worker registration failed: ', err);
                });
            });
        }
        // --- Конец регистрации Service Worker ---

        initializeScene();

        window.addEventListener('resize', () => {
            setCanvasSize();
        });
    </script>
</body>
</html>
